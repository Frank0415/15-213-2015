### **Y86-64 指令集详解**
Y86-64 是一个简化的 64 位指令集架构（ISA），用于教学目的（如 CSAPP 课程）。它的设计模仿了 x86-64 的核心功能，但更简洁，适合学习 CPU 流水线、硬件实现等概念。

---

## **1. 指令格式**
Y86-64 指令的编码长度为 **1~10 字节**，由以下部分组成：
1. **1 字节指令标识符（Instruction Specifier）**：
   - 高 4 位：操作码（`icode`）。
   - 低 4 位：功能码（`ifun`），用于区分同类型的指令（如不同条件的跳转）。
2. **可选的 1 字节寄存器标识符（Register Specifier）**：
   - 高 4 位：源寄存器（`rA`）。
   - 低 4 位：目标寄存器（`rB`）。
3. **可选的 8 字节常数（Constant Word）**：
   - 用于立即数（`irmovq`）、位移量（`rmmovq`/`mrmovq`）或跳转目标地址（`jXX`/`call`）。

---

## **2. 指令分类与功能**
### **(1) 停机与空操作**
| 指令   | 编码 | 功能                          |
|--------|------|-------------------------------|
| `halt` | `0`  | 停止程序执行，状态码设为 `HLT` |
| `nop`  | `1`  | 无操作（占位）                |

---

### **(2) 数据移动指令**
| 指令              | 编码 | 功能                                   |
|-------------------|------|----------------------------------------|
| `rrmovq rA, rB`   | `2`  | 将 `rA` 的值复制到 `rB`（无条件移动） |
| `irmovq V, rB`    | `3`  | 将立即数 `V` 存入 `rB`                |
| `rmmovq rA, D(rB)`| `4`  | 将 `rA` 的值存入内存 `D + rB` 处      |
| `mrmovq D(rB), rA`| `5`  | 从内存 `D + rB` 处加载值到 `rA`       |

**注**：
- `D` 是 8 字节的位移量（如 `rmmovq %rax, 0x100(%rcx)`）。
- `rA` 和 `rB` 是寄存器编号（见下方寄存器表）。

---

### **(3) 算术逻辑运算（OPq）**
| 指令       | 编码 | 功能码（`ifun`） | 功能                     |
|------------|------|------------------|--------------------------|
| `addq rA, rB` | `6`  | `0`              | `rB = rB + rA`           |
| `subq rA, rB` | `6`  | `1`              | `rB = rB - rA`           |
| `andq rA, rB` | `6`  | `2`              | `rB = rB & rA`           |
| `xorq rA, rB` | `6`  | `3`              | `rB = rB ^ rA`           |

**注**：
- 运算会设置条件码（`ZF`、`SF`、`OF`），用于条件跳转和条件移动。

---

### **(4) 跳转指令（jXX）**
| 指令    | 编码 | 功能码（`ifun`） | 跳转条件                     |
|---------|------|------------------|------------------------------|
| `jmp`   | `7`  | `0`              | 无条件跳转                   |
| `jle`   | `7`  | `1`              | `(SF ^ OF) \| ZF`            |
| `jl`    | `7`  | `2`              | `SF ^ OF`                    |
| `je`    | `7`  | `3`              | `ZF`                         |
| `jne`   | `7`  | `4`              | `~ZF`                        |
| `jge`   | `7`  | `5`              | `~(SF ^ OF)`                 |
| `jg`    | `7`  | `6`              | `~(SF ^ OF) & ~ZF`           |

**注**：
- `Dest` 是 8 字节的目标地址（如 `jmp 0x400776`）。

---

### **(5) 条件移动指令（cmovXX）**
| 指令       | 编码 | 功能码（`ifun`） | 移动条件（同跳转指令） |
|------------|------|------------------|------------------------|
| `cmovle`   | `2`  | `1`              | `(SF ^ OF) \| ZF`      |
| `cmovl`    | `2`  | `2`              | `SF ^ OF`              |
| `cmove`    | `2`  | `3`              | `ZF`                   |
| `cmovne`   | `2`  | `4`              | `~ZF`                  |
| `cmovge`   | `2`  | `5`              | `~(SF ^ OF)`           |
| `cmovg`    | `2`  | `6`              | `~(SF ^ OF) & ~ZF`     |

**注**：
- 格式与 `rrmovq` 相同，但仅在条件满足时移动数据。

---

### **(6) 函数调用与栈操作**
| 指令        | 编码 | 功能                                   |
|-------------|------|----------------------------------------|
| `call Dest` | `8`  | 将返回地址压栈，并跳转到 `Dest`        |
| `ret`       | `9`  | 从栈弹出返回地址，并跳转               |
| `pushq rA`  | `A`  | 将 `rA` 的值压栈                       |
| `popq rA`   | `B`  | 从栈弹出值到 `rA`                      |

**注**：
- `pushq` 和 `popq` 会隐式更新栈指针 `%rsp`。

---

## **3. 寄存器编码**
Y86-64 使用 15 个寄存器（编号 0x0~0xE），与 x86-64 的寄存器对应：

| 编号（十六进制） | 寄存器 |
|------------------|--------|
| `0`              | `%rax` |
| `1`              | `%rcx` |
| `2`              | `%rdx` |
| `3`              | `%rbx` |
| `4`              | `%rsp` |
| `5`              | `%rbp` |
| `6`              | `%rsi` |
| `7`              | `%rdi` |
| `8`              | `%r8`  |
| `9`              | `%r9`  |
| `A`              | `%r10` |
| `B`              | `%r11` |
| `C`              | `%r12` |
| `D`              | `%r13` |
| `E`              | `%r14` |
| `F`              | 无寄存器（用于占位） |

---

## **4. 指令编码示例**
### **示例 1：`irmovq $0x1234, %rdx`**
```
0x30 0x2F 0x0000000000001234
```
- `0x30`：`icode=3`（`irmovq`），`ifun=0`（无功能码）。
- `0x2F`：`rA=0xF`（无源寄存器），`rB=0x2`（`%rdx`）。
- `0x0000000000001234`：立即数 `0x1234`。

### **示例 2：`addq %rax, %rcx`**
```
0x60 0x10
```
- `0x60`：`icode=6`（`OPq`），`ifun=0`（`addq`）。
- `0x10`：`rA=0x1`（`%rcx`），`rB=0x0`（`%rax`）。

---

## **5. 关键点总结**
1. **Y86-64 是 x86-64 的简化版**，去除了复杂寻址模式和浮点运算。
2. **条件码（`ZF`、`SF`、`OF`）** 用于控制条件跳转和条件移动。
3. **栈操作** 通过 `pushq`/`popq` 和 `call`/`ret` 实现。
4. **立即数和内存访问** 需要 8 字节的附加数据。

**用途**：学习 CPU 设计、流水线、数据冒险等底层概念。

### **Y86-64 指令执行阶段的详细解释**
Y86-64 的指令执行被划分为 **6 个阶段**，类似于现代处理器的流水线设计。每个阶段完成特定任务，最终组合起来实现一条指令的完整执行。以下是每个阶段的具体功能：

---

## **1. 取指（Fetch）**
**功能**：从内存中读取指令，并解析指令的各个字段。  
**关键操作**：
1. **读取指令字节**：
   - 根据程序计数器（`PC`）的值，从内存中读取指令。
   - 例如，如果 `PC = 0x4000`，则从地址 `0x4000` 开始读取指令。
2. **解析指令字段**：
   - 第一个字节（指令指示符）被拆分为：
     - 高 4 位：`icode`（指令类型，如 `mov`、`add` 等）。
     - 低 4 位：`ifun`（功能码，如 `addq` vs `subq`）。
   - 可能读取额外的字节：
     - 寄存器指示符（`rA` 和 `rB`）。
     - 8 字节常数字（如 `irmovq` 的立即数或跳转目标地址）。
3. **计算下一条指令地址（`valP`）**：
   - `valP = PC + 当前指令的长度`。
   - 例如，`irmovq` 指令占 10 字节（1 字节 `icode` + 1 字节 `rA/rB` + 8 字节立即数），所以 `valP = PC + 10`。

**示例**：  
指令 `irmovq $0x1234, %rdx` 的取指过程：
- `PC = 0x4000`，读取 `0x4000` 处的字节 `0x30`（`icode=3`, `ifun=0`）。
- 继续读取 `0x4001` 的寄存器字节 `0x2F`（`rA=0xF`，`rB=0x2`）。
- 读取 `0x4002` 开始的 8 字节立即数 `0x1234`。
- `valP = 0x4000 + 10 = 0x400A`（下一条指令地址）。

---

## **2. 译码（Decode）**
**功能**：从寄存器文件中读取操作数的值。  
**关键操作**：
1. **读取寄存器值**：
   - 根据 `rA` 和 `rB` 字段，从寄存器文件中读取 `valA` 和 `valB`。
   - 某些指令（如 `pushq`/`popq`）会隐式使用 `%rsp`（栈指针）。
2. **特殊情况的处理**：
   - 对于 `rmmovq` 或 `mrmovq`，`rB` 是基址寄存器（用于计算内存地址）。
   - 对于 `call` 或 `ret`，`%rsp` 会被隐式修改。

**示例**：  
指令 `addq %rax, %rcx` 的译码过程：
- `rA = 0x0`（`%rax`），`rB = 0x1`（`%rcx`）。
- 从寄存器文件读取：
  - `valA = %rax` 的值。
  - `valB = %rcx` 的值。

---

## **3. 执行（Execute）**
**功能**：通过 ALU 执行计算或逻辑操作。  
**关键操作**：
1. **算术/逻辑运算**：
   - 对 `OPq` 指令（如 `addq`），ALU 根据 `ifun` 执行操作：
     - `valE = valB OP valA`（如 `valE = %rcx + %rax`）。
   - 设置条件码（`ZF`、`SF`、`OF`）。
2. **内存地址计算**：
   - 对 `rmmovq` 或 `mrmovq`，计算有效地址：
     - `valE = valB + D`（`D` 是位移量）。
3. **条件移动或跳转的判断**：
   - 对 `cmovXX`，检查条件码决定是否更新 `rB`。
   - 对 `jXX`，检查条件码决定是否跳转。

**示例**：  
指令 `addq %rax, %rcx` 的执行过程：
- ALU 计算 `valE = %rcx + %rax`。
- 更新条件码（如果结果为 0，则 `ZF=1`；如果溢出，则 `OF=1`）。

---

## **4. 访存（Memory）**
**功能**：与内存交互（读或写）。  
**关键操作**：
1. **加载数据（`mrmovq`）**：
   - 从地址 `valE` 读取 8 字节到 `valM`。
2. **存储数据（`rmmovq`）**：
   - 将 `valA` 的值写入地址 `valE`。
3. **栈操作（`pushq`/`popq`）**：
   - `pushq`：将 `valA` 写入 `%rsp - 8`。
   - `popq`：从 `%rsp` 读取 `valM`。

**示例**：  
指令 `mrmovq 0x100(%rcx), %rax` 的访存过程：
- 执行阶段已计算 `valE = %rcx + 0x100`。
- 从内存 `valE` 处读取 8 字节到 `valM`。

---

## **5. 写回（Write Back）**
**功能**：将结果写回寄存器文件。  
**关键操作**：
1. **更新寄存器**：
   - 对 `OPq` 指令，将 `valE` 写入 `rB`。
   - 对 `mrmovq`，将 `valM` 写入 `rA`。
   - 对 `popq`，将 `valM` 写入 `rA`，并更新 `%rsp`。
2. **条件移动的特殊处理**：
   - 只有条件满足时，才更新目标寄存器。

**示例**：  
指令 `addq %rax, %rcx` 的写回过程：
- 将 `valE`（`%rcx + %rax` 的结果）写回 `%rcx`。

---

## **6. 更新 PC（PC Update）**
**功能**：确定下一条指令的地址。  
**关键操作**：
1. **默认情况**：
   - `PC = valP`（取指阶段计算的下一条指令地址）。
2. **跳转或调用**：
   - `jXX`：如果条件成立，`PC = Dest`；否则 `PC = valP`。
   - `call`：`PC = Dest`。
   - `ret`：`PC = valM`（从栈弹出的返回地址）。

**示例**：  
指令 `je 0x4000` 的 PC 更新：
- 如果 `ZF=1`（条件成立），则 `PC = 0x4000`。
- 否则 `PC = valP`（下一条顺序指令）。

---

## **总结**
| 阶段      | 功能                                                                 | 关键输出               |
|-----------|----------------------------------------------------------------------|------------------------|
| 取指      | 读取指令，解析 `icode`/`ifun`，计算 `valP`                          | `icode`, `ifun`, `valP`|
| 译码      | 从寄存器文件读取 `valA` 和 `valB`                                   | `valA`, `valB`         |
| 执行      | ALU 计算 `valE`，设置条件码，判断跳转/条件移动                      | `valE`, 条件码         |
| 访存      | 读写内存（`valM`）                                                  | `valM`                 |
| 写回      | 将结果写回寄存器                                                    | 更新寄存器             |
| 更新 PC   | 设置 `PC` 为下一条指令地址（可能是跳转目标或 `valP`）               | 新的 `PC`              |

**核心思想**：  
Y86-64 通过分阶段执行指令，模拟了现代 CPU 的流水线设计。每个阶段专注于单一任务，最终组合完成指令的完整执行。这种设计便于理解 CPU 的工作原理，也是后续学习流水线冲突、数据冒险等内容的基础。